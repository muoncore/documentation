:date: 2015-01-05 11:40
:source-highlighter: pygments
:toc: right
:toc-title: Event Microservices
:toclevels: 6

Learning how to use event data in Muon.

## Setup

MicroserviceUX provides specific facilities for managing event based, stream oriented data. As in all things, this is available
as a set of distinct microservices. When running, they provide a data platform for building event based systems.

TODO - MENTION PHOTON, OTHERS?

## Understanding Events

Understanding your data, how it moves, what it means, is one of the most useful and powerful things that you as a software developer
can do. Too often the pressure is on to understand your data in terms of how it should be _presented_. By it's very nature this means
that you take a snapshot in time of your data, and fold it into the shap you want. Often, you will do this ahead of time in the form
of a normalised database schema.

Imagine if you didn't do this. Imagine instead that you looked on your data as it changes, on what _happens_ to make it.

This is the nature of event based systems, they are described in terms of _what happens_ rather than what questions you want to answer later on.

THe MicroserviceUX toolkit has this baked in deeply, and via the Photon project and event client libraries, can give you a rich, simple event
model that focuses on *events*, *streams* and queries across projections that we refer to as *projections*.

The Microservice architecture is intented to enable change, primarily by generating isolation between services, often using a network,
sometimes using some other common interface.

Adding events into the mix, specifically event sourcing, allows decoupling in time. Many times your services are truly connected in time
(_what is the current basket state_), however many things truly aren't connected in time (_eg, send an email_).

Event architectures give you this option.

The rest of this guide will show you how to build an event based system using MicroserviceUX technologies.

We will be implementing a user registration system, allowing the creation of user accounts and loading / using a user account.

## Design Your Events

When building an event based system, the first thing you need to figure out is _what should happen_, a series of things that you expect to occur, along with the data that goes with that.
These actions, happenings, are your events. Next, you can figure out how to convert the data in your events into something you can query.

For our user registration system, the following things will happen :-

* User registers
* User updates their record
* User removes their record

We will want to show :-

* a list of the current users
* a single user account

## Emitting an Event

To get started, we need to be able to emit an event. We will have two events in the system to start with, ```UserRegistered``` and ```UserRemoved```

UserRegistered will look like this

```
 username: <string>
 firstname: <string>
 lastname: <string>
```

UserRemoved will look like this

```
 username: <string>
```

Using Muon, this is easy, you obtain the _Event Client_, and then call emit.

[source,{language},indent=0]
----
include::{emitevent}[]
----

This is all!  Your event is now persisted, and available for replay or analysis.

It is possible to react to events as they are emitted by _subscribing_ to the appropriate event stream.
Your code will then receive a push notification whenever an event is emitted.

You can also, after the fact, replay all of the events and do some analysis. You may also combine these, replay the historical events
and then once they have been consumed, continue to process new events, live, as they are emitted.

## Subscribing and acting on Events

All events in MicroserviceUX are arranged into _streams_. These are ordered, serial lists of events, stored in the order
that they were persisted in.

[NOTE]
====
Try doing this part in another language to your emitting code and see how they work together.
====

Your microservices can subscribe to a stream to be notified whenever a new event occurs, so they can react to it, use it, or discard it.

Subscribe a service to the user stream using the event client. This will notify your service of the user events as they occur. You can act on these to take further
 actions, sending an email, validating an account etc.

[source,{language},indent=0]
----
include::{subscribeevent}[]
----

## Replaying an Event Stream - Building an Event Sourced Aggregation from an Event Stream

We want to build a list of users. To do that, we have to transform the events as they come into our service to generate an aggregation of the events.

To do this, we build a simple data sturcture, a list, and then for every event that we are notified of, we change the list. If we take all the events that have ever occurred,
we can rebuild our current state at any time.

[source,{language},indent=0]
----
include::{buildaggregation}[]
----

This maintains the list of users in memory, for the fastest possible access. Rebuilding the list of users is natural, if potentially involved, by
replaying the users stream on demand. In the case of the user service crashing, the user list will be recreated from the event stream.

The user data is in a very convenient representation, a queryable list, but it is *mastered* elsewhere, in the event store.

This pattern of generating an aggregation across an event stream is very common, and so we have created a special _Projection_ service
in the event system of MicroserviceUX.

## Using an Event Projection in place of an Aggregation

To build an event projection, you need to understand the algorithm that you have just written. This is a general purpose computation known as a
_reducer_. It takes an initial state and for a stream of data items applies a mutation to the state before moving on to process the next item
in the list. It is fairly simple, general purpose and able to be parallelised.

The Photon store or Collider projection host can take a reducer function and associated metadata and generate an event projection on a stream.

This allows you to do the work you did in your service and push it back into the MicroserviceUX data tier.

To do this, you first need to insert a projection. This can be written in a variety of languages, here it is in {projectionlanguage}

[source,{projectionlanguage},indent=0]
----
include::{userlistprojection}[]
----

This simply folds the stream data into a list. Every UserRegistered event acts as an insert, every UserRemoved acts as a delete.

You may register this using the event client like so

[source,{language},indent=0]
----
include::{installprojection}[]
----

This will run against the event stream, and maintain an up to date list representation of your users. You can query the state of the projection
as below.

[source,{language},indent=0]
----
include::{useprojection}[]
----

Your user service can now become a much simpler system, delivering a user friendly API on top of an event projection.
